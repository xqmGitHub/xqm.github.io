<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>点点滴滴</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.gotwo.top/"/>
  <updated>2020-11-22T15:25:32.941Z</updated>
  <id>https://blog.gotwo.top/</id>
  
  <author>
    <name>Xiong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MongoDB 数据更新操作</title>
    <link href="https://blog.gotwo.top/mongodb-update.html"/>
    <id>https://blog.gotwo.top/mongodb-update.html</id>
    <published>2020-09-24T11:07:37.000Z</published>
    <updated>2020-11-22T15:25:32.941Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MongoDB-更新文档"><a href="#MongoDB-更新文档" class="headerlink" title="MongoDB 更新文档"></a>MongoDB 更新文档</h4><p>MongoDB 使用 <code>update()</code> 和 <code>save()</code> 方法来更新集合中的文档。</p><h5 id="update-方法"><a href="#update-方法" class="headerlink" title="update() 方法"></a><code>update()</code> 方法</h5><p><code>update()</code> 方法用于更新已存在的文档。语法格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">    &lt;query&gt;,</span><br><span class="line">    &lt;update&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">      upsert: &lt;boolean&gt;,</span><br><span class="line">      multi: &lt;boolean&gt;,</span><br><span class="line">      writeConcern: &lt;document&gt;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h5 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h5><ul><li><strong><code>query</code></strong> : update 的查询条件，类似 sql update 查询内 where 后面的。</li><li><strong><code>update</code></strong> : update 的对象和一些更新的操作符（如$,$inc…）等，也可以理解为 sql update 查询内 <code>set</code> 后面的</li><li><strong><code>upsert</code></strong> : 可选，这个参数的意思是，如果不存在 update 的记录，是否插入 <code>objNew</code>,<code>true</code> 为插入，默认是 <code>false</code>，不插入。</li><li><strong><code>multi</code></strong> : 可选，mongodb 默认是 <code>false</code>,只更新找到的第一条记录，如果这个参数为 <code>true</code>,就把按条件查出来多条记录全部更新。</li><li><strong><code>writeConcern</code></strong> :可选，抛出异常的级别。</li></ul><p><a href="https://docs.mongodb.com/manual/reference/update-methods/" target="_blank" rel="noopener">官方连接连接地址</a></p><a id="more"></a><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>向数据库插入点数据（集合名称为 test)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  _id: 100,</span><br><span class="line">  sku: &quot;abc123&quot;,</span><br><span class="line">  quantity: 200,</span><br><span class="line">  instock: true,</span><br><span class="line">  reorder: false,</span><br><span class="line">  details: &#123; model: &quot;1Q2&quot;, make: &quot;xyz&quot; &#125;,</span><br><span class="line">  tags: [ &quot;apparel&quot;, &quot;clothing&quot; ],</span><br><span class="line">  ratings: [ &#123; by: &quot;ijk&quot;, rating: 1 &#125; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="各种更新操作符"><a href="#各种更新操作符" class="headerlink" title="各种更新操作符"></a>各种更新操作符</h4><h5 id="set"><a href="#set" class="headerlink" title="$set"></a><code>$set</code></h5><p>用来指定一个键的值。如果这个键不存在，则创建它。<br>示例：更新 quantity 字段、更新 details 的内容以及更新 tags 的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.test.update(</span><br><span class="line">   &#123; _id: 100 &#125;,</span><br><span class="line">   &#123; $set:</span><br><span class="line">      &#123;</span><br><span class="line">        quantity: 500,</span><br><span class="line">        details: &#123; model: &quot;1Q2&quot;, make: &quot;xyz&quot; &#125;,</span><br><span class="line">        tags: [ &quot;coats&quot;, &quot;outerwear&quot;, &quot;clothing&quot; ]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h5 id="set-与-操作"><a href="#set-与-操作" class="headerlink" title="$set 与 . 操作"></a><code>$set</code> 与 <code>.</code> 操作</h5><p>示例：使用 “.” 符号更新数据内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.test.update(</span><br><span class="line">   &#123; _id: 100 &#125;,</span><br><span class="line">   &#123; $set: &#123; &quot;details.make&quot;: &quot;zzz&quot; &#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>同样可以使用 <code>.</code> 符号操作数组内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.test.update(</span><br><span class="line">   &#123; _id: 100 &#125;,</span><br><span class="line">   &#123; $set:</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;tags.1&quot;: &quot;rain gear&quot;,</span><br><span class="line">        &quot;ratings.0.rating&quot;: 2</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>创建不存在的 key 值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.tset.update(</span><br><span class="line">   &#123; _id: 100 &#125;,</span><br><span class="line">   &#123; $set:</span><br><span class="line">      &#123; &quot;name&quot;: &quot;not the name&quot; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h5 id="unset"><a href="#unset" class="headerlink" title="$unset"></a><code>$unset</code></h5><p>从文档中移除指定的键。<br>若要完全删除键 “name” ,使用 <code>$unset</code> 即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.test.update(</span><br><span class="line">   &#123; _id: 100 &#125;,</span><br><span class="line">   &#123; $unset:</span><br><span class="line">      &#123; &quot;name&quot;: 1 &#125;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h5 id="inc"><a href="#inc" class="headerlink" title="$inc"></a><code>$inc</code></h5><ul><li><p><code>$inc</code> 修改器用来增加已有键的值，或者在键不存在时创建一个键。<code>inc</code> 就是专门来增加（和减少）数字的。</p></li><li><p><code>$inc</code> 只能用于整数、长整数或双精度浮点数。要是用在其他类型的数据上就会导致操作失败。</p></li><li><p><code>$inc</code> 可以接收正数或者负数的值。</p></li></ul><p>示例：将 “quantity” 值减少 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.test.update(</span><br><span class="line">   &#123; _id: 100 &#125;,</span><br><span class="line">   &#123; $inc :</span><br><span class="line">      &#123; &quot;quantity&quot;: -1 &#125;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h5 id="rename"><a href="#rename" class="headerlink" title="$rename"></a><code>$rename</code></h5><p>操作符可以重命名字段名称，新的字段名称不能和文档中现有的字段名相同。</p><p>语法</p><p><code>{ $rename: { &lt;old name1&gt;: &lt;new name1&gt;, &lt;old name2&gt;: &lt;new name2&gt;, ... } }</code></p><p>示例：修改 “sku” 为 “skuName”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.test.update(</span><br><span class="line">   &#123; _id: 100 &#125;,</span><br><span class="line">   &#123; $rename :</span><br><span class="line">      &#123; &quot;sku&quot;: &quot;skuName&quot; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h5 id="pop"><a href="#pop" class="headerlink" title="$pop"></a><code>$pop</code></h5><p>只能用于对 数组（array）进行操作。用于移除数组第一个元素，或者用于移除数组的最后一个元素。<br>语法 -1 表示移除数组第一个元素， 1 表示移除数组最后一个元素</p><p><code>{ $pop: { &lt;field&gt;: &lt;-1 | 1&gt;, ... } }</code></p><p>集合数据 <code>{ _id: 1, scores: [ 8, 9, 10 ] }</code></p><ul><li><p>移除第一个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.test.update( &#123; _id: 1 &#125;, &#123; $pop: &#123; scores: -1 &#125; &#125; )</span><br><span class="line"> </span><br><span class="line">// 查询返回</span><br><span class="line">&#123; _id: 1, scores: [ 9, 10 ] &#125;</span><br></pre></td></tr></table></figure></li><li><p>移除最后一个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.test.update( &#123; _id: 1 &#125;, &#123; $pop: &#123; scores: 1 &#125; &#125; ) </span><br><span class="line">// 查询返回 </span><br><span class="line">&#123; _id: 1, scores: [ 9 ] &#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="push"><a href="#push" class="headerlink" title="$push"></a>$push</h5><p>如果指定的键已经存在，会向已有的数组末尾加入一个元素，要是没有就会创建一个新的数组。<br>集合数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_id&quot; : 1000,</span><br><span class="line">    &quot;details&quot; : &#123;</span><br><span class="line">        &quot;model&quot; : &quot;14Q3&quot;,</span><br><span class="line">        &quot;make&quot; : &quot;zzz&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;tags&quot; : [ </span><br><span class="line">        &quot;coats&quot;, </span><br><span class="line">        &quot;outerwear&quot;, </span><br><span class="line">        &quot;clothing&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;sku&quot; : &quot;abc123&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>向 tags 中增加一个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.test.update( &#123; _id: 1000&#125;, &#123; $push: &#123;tags: &quot;push&quot;&#125; &#125; ); </span><br><span class="line">// 返回结果 </span><br><span class="line">&#123;...&quot;tags&quot; : [ &quot;coats&quot;, &quot;outerwear&quot;, &quot;clothing&quot;, &quot;push&quot;], ...&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加一个不存在的 key “name”</p></li></ul><p><code>db.getCollection(&#39;test&#39;).update( {_id : 100}, {$push: { name : &quot;sku&quot; } } );</code></p><p><strong>注意：<code>push</code> 只能对数组进行操作。</strong></p><h5 id="addToSet"><a href="#addToSet" class="headerlink" title="$addToSet"></a><code>$addToSet</code></h5><p>向集合数据中添加数组内容，如果数据存在就做追加操作，如果数据不存在就做新增 key 与内容操作。</p><p>语法 </p><p><code>{&quot;$addToSet&quot; : {成员： 内容} }</code></p><ul><li>向数据中的 name 字段追加内容（紧接着前面”$push”操作的数据来）</li></ul><p><code>db.getCollection(&#39;test&#39;).update( {_id : 100}, { $addToSet : { name : &quot;Name&quot; } } );</code></p><ul><li>追加一个不存在的 key item （此时的操作和 <code>$push</code> 类似）</li></ul><p><code>db.getCollection(&#39;test&#39;).update( {_id : 100}, { $addToSet : { item : &quot;Name&quot; } } );</code></p><h5 id="pull"><a href="#pull" class="headerlink" title="$pull"></a><code>$pull</code></h5><p>语法</p><p><code>{ $pull: { &lt;field1&gt;: &lt;value|condition&gt;, &lt;field2&gt;: &lt;value|condition&gt;, ... } }</code></p><p> pull操作符移除指定字段值为数组，且匹配pull操作符移除指定字段值为数组，且匹配pull语句声明的查询条件的所有元素。</p><ul><li><p>移除 tags 中的 “push” 与 “coats” 值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.test.update(</span><br><span class="line">    &#123; _id : 100 &#125;,</span><br><span class="line">    &#123; $pull: &#123; tags: &#123; $in: [ &quot;push&quot;, &quot;coats&quot; ] &#125; &#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>移除 name 中的 “Name”</p></li></ul><p><code>db.test.update( { _id : 100 }, { $pull: { name : &quot;Name&quot; } } )</code></p><h5 id="findAndModify"><a href="#findAndModify" class="headerlink" title="findAndModify()"></a>findAndModify()</h5><p>语法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">db.test.findAndModify(&#123;</span><br><span class="line">    query: &lt;document&gt;,</span><br><span class="line">    sort: &lt;document&gt;,</span><br><span class="line">    remove: &lt;boolean&gt;,</span><br><span class="line">    update: &lt;document&gt;,</span><br><span class="line">    new: &lt;boolean&gt;,</span><br><span class="line">    fields: &lt;document&gt;,</span><br><span class="line">    upsert: &lt;boolean&gt;,</span><br><span class="line">    bypassDocumentValidation: &lt;boolean&gt;,</span><br><span class="line">    writeConcern: &lt;document&gt;,</span><br><span class="line">    collation: &lt;document&gt;,</span><br><span class="line">    arrayFilters: [ &lt;filterdocument1&gt;, ... ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果我们想对 某个数据进行全部修改，就可以使用 <code>findAndModify()</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">db.test.findAndModify(&#123;</span><br><span class="line">   query: &#123; _id: 100&#125;,</span><br><span class="line">   update: &#123;</span><br><span class="line">    &quot;details&quot; : &#123;</span><br><span class="line">        &quot;model&quot; : &quot;12Q3&quot;,</span><br><span class="line">        &quot;make&quot; : &quot;zzz&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;tags&quot; : [ </span><br><span class="line">        &quot;coats&quot;, </span><br><span class="line">        &quot;outerwear&quot;, </span><br><span class="line">        &quot;clothing&quot;, </span><br><span class="line">        &quot;push&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;sku&quot; : &quot;abc123&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><a href="https://docs.mongodb.com/manual/reference/operator/update/" target="_blank" rel="noopener">官网链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;MongoDB-更新文档&quot;&gt;&lt;a href=&quot;#MongoDB-更新文档&quot; class=&quot;headerlink&quot; title=&quot;MongoDB 更新文档&quot;&gt;&lt;/a&gt;MongoDB 更新文档&lt;/h4&gt;&lt;p&gt;MongoDB 使用 &lt;code&gt;update()&lt;/code&gt; 和 &lt;code&gt;save()&lt;/code&gt; 方法来更新集合中的文档。&lt;/p&gt;
&lt;h5 id=&quot;update-方法&quot;&gt;&lt;a href=&quot;#update-方法&quot; class=&quot;headerlink&quot; title=&quot;update() 方法&quot;&gt;&lt;/a&gt;&lt;code&gt;update()&lt;/code&gt; 方法&lt;/h5&gt;&lt;p&gt;&lt;code&gt;update()&lt;/code&gt; 方法用于更新已存在的文档。语法格式如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;db.collection.update(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;query&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;update&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      upsert: &amp;lt;boolean&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      multi: &amp;lt;boolean&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      writeConcern: &amp;lt;document&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h5 id=&quot;参数说明：&quot;&gt;&lt;a href=&quot;#参数说明：&quot; class=&quot;headerlink&quot; title=&quot;参数说明：&quot;&gt;&lt;/a&gt;参数说明：&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;query&lt;/code&gt;&lt;/strong&gt; : update 的查询条件，类似 sql update 查询内 where 后面的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;update&lt;/code&gt;&lt;/strong&gt; : update 的对象和一些更新的操作符（如$,$inc…）等，也可以理解为 sql update 查询内 &lt;code&gt;set&lt;/code&gt; 后面的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;upsert&lt;/code&gt;&lt;/strong&gt; : 可选，这个参数的意思是，如果不存在 update 的记录，是否插入 &lt;code&gt;objNew&lt;/code&gt;,&lt;code&gt;true&lt;/code&gt; 为插入，默认是 &lt;code&gt;false&lt;/code&gt;，不插入。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;multi&lt;/code&gt;&lt;/strong&gt; : 可选，mongodb 默认是 &lt;code&gt;false&lt;/code&gt;,只更新找到的第一条记录，如果这个参数为 &lt;code&gt;true&lt;/code&gt;,就把按条件查出来多条记录全部更新。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;writeConcern&lt;/code&gt;&lt;/strong&gt; :可选，抛出异常的级别。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/update-methods/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方连接连接地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://blog.gotwo.top/categories/MongoDB/"/>
    
    
      <category term="mongodb" scheme="https://blog.gotwo.top/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>git 远程连接由 https 换成 ssh</title>
    <link href="https://blog.gotwo.top/git-https2ssh.html"/>
    <id>https://blog.gotwo.top/git-https2ssh.html</id>
    <published>2020-09-20T14:26:22.000Z</published>
    <updated>2020-11-22T15:25:32.941Z</updated>
    
    <content type="html"><![CDATA[<p>在github.com上 建立了一个小项目，push 的时候，提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &apos;https://github.com/xxx.git/&apos;: error setting certificate verify locations: </span><br><span class="line">CAfile: D:/Git/mingw64/ssl/certs/ca-bundle.crtle </span><br><span class="line">CApath: none</span><br></pre></td></tr></table></figure></p><p>而且用 https 在 push 都要输入用户名和密码，很是麻烦</p><p>还是 ssh 方便 下面把它换成 ssh 方式的</p><p><code>git remote -v</code></p><p>可以看到形如一下的返回结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">origin https://github.com/xxx.git (fetch)</span><br><span class="line"></span><br><span class="line">origin https://github.com/xxx.git (push)</span><br></pre></td></tr></table></figure></p><ul><li>移除本地分支<br><code>git remote rm origin</code></li><li>添加远程分支<br><code>git remote add origin &#39;git@github.com:xxx/***.git&#39;</code></li><li>最后就阔以愉快的用 ssh 方式了（前提是配置了 ssh key）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在github.com上 建立了一个小项目，push 的时候，提示&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;s
      
    
    </summary>
    
      <category term="Git" scheme="https://blog.gotwo.top/categories/Git/"/>
    
    
      <category term="Git" scheme="https://blog.gotwo.top/tags/Git/"/>
    
      <category term="ssh" scheme="https://blog.gotwo.top/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>mysql 数据库的主从同步</title>
    <link href="https://blog.gotwo.top/mysql-master-slave.html"/>
    <id>https://blog.gotwo.top/mysql-master-slave.html</id>
    <published>2020-07-04T15:09:21.000Z</published>
    <updated>2020-11-22T15:25:32.941Z</updated>
    
    <content type="html"><![CDATA[<p>大型网站为了软解大量的并发访问，除了在网站实现分布式负载均衡，远远不够.<br>到了数据业务层、数据访问层，如果还是传统的数据结构，<br>或者只是单单靠一台服务器来处理如此多的数据库连接操作，数据库必然会崩溃，特别是数据丢失的话，后果更是不堪设想.<br>利用主从数据库来实现读写分离，从而分担主数据库的压力.<br>在多个服务器上部署 mysql，将其中一台认为主数据库，而其他为从数据库，实现主从同步.<br>其中主数据库负责主动写的操作，而从数据库则只负责主动读的操作（slave 从数据库仍然会被动的进行写操作，为了保持数据一致性），<br>这样就可以很大程度上的避免数据丢失的问题，同时也可减少数据库的连接，减轻主数据库的负载.</p><p>主从同步复制有以下几种方式：</p><ul><li>同步复制：master 的变化，必须等待 slave-1,slave-2,…,slave-n 完成后才能返回。</li><li>异步复制：master 只需要完成自己的数据库操作即可，至于 slaves 是否收到二进制日志，是否完成操作，不用关心。MYSQL 的默认设置。</li><li>半同步复制：master 只保证 slaves 中的一个操作成功，就返回，其他 slave 不管。这个功能，是由 google 为 MYSQL 引入的。</li></ul><p>mysql 主从复制的思路：</p><ul><li>配置主服务器，即 msater，使之具备一下能力(主要接受用户的写操作，并且负责将二进制日志同步给从服务器)<ul><li>记录二进制日志</li><li>为从服务提供一个用户(设置密码)，提高二进制日志同步得安全性</li></ul></li></ul><ul><li>配置从服务器，即 slave，使之具备一下能力(主要负责用户的读操作(分担主服务器的读写压力)，并且负责重放 master的 写操作，还能实现容灾能力，保证高可用)<ul><li>记录中继日志</li><li>连接到 mysql 可以启动 slave 功能，并且设置 master 信息，通过配置信息，开启 IO_THREAD 和 SQL_THREAD 线程</li></ul></li></ul><a id="more"></a><p>下面是在centos 7系统上，实现的 mysql5.7 数据库的主从同步配置，从而实现读写分离操作。</p><p>这里测试的两台服务器的IP地址分别为主服务器（192.168.2.19）和从服务器（192.168.2.169）<br>分别在这两个服务器上创建test数据库，以备后面测试。</p><h5 id="master-主服务器的配置"><a href="#master-主服务器的配置" class="headerlink" title="master 主服务器的配置"></a>master 主服务器的配置</h5><ul><li><p>配置文件my.cnf的修改<br><code>vim /etc/my.cnf</code><br>在 <code>[mysqld]</code> 中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#备注：</span><br><span class="line">#server-id 服务器唯一标识。</span><br><span class="line">#log_bin 启动MySQL二进制日志，即数据同步语句，从数据库会一条一条的执行这些语句。</span><br><span class="line">#binlog_do_db 指定记录二进制日志的数据库，即需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可。</span><br><span class="line">#binlog_ignore_db 指定不记录二进制日志的数据库，即不需要复制的数据库名，如果有多个数据库，重复设置这个选项即可。</span><br><span class="line">#其中需要注意的是，binlog_do_db和binlog_ignore_db为互斥选项，一般只需要一个即可。</span><br><span class="line"></span><br><span class="line">server-id=1</span><br><span class="line">log_bin=master-bin</span><br><span class="line">log_bin_index=master-bin.index</span><br><span class="line">binlog_do_db=test</span><br></pre></td></tr></table></figure></li><li><p>创建从服务器的用户和权限<br>进入主 mysql 数据库 <code>mysql -uroot -p</code><br>创建从数据库的 <code>masterbackup</code> 用户和权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#备注</span><br><span class="line">#192.168.2.%通配符，表示0-255的IP都可访问主服务器，正式环境请配置指定从服务器IP</span><br><span class="line">#若将 192.168.2.% 改为 %，则任何ip均可作为其从数据库来访问主服务器</span><br><span class="line">grant replication slave on *.* to masterbackup@&apos;192.168.2.%&apos; identified by &apos;12345678&apos;;</span><br><span class="line"># 刷新权限信息</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>重启mysql服务 <code>service mysqld restart</code></p></li><li><p>查看主服务器状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br><span class="line">+-------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File              | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+-------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| master-bin.000001 |      154 | test         |                  |                   |</span><br><span class="line">+-------------------+----------+--------------+------------------+-------------------+</span><br></pre></td></tr></table></figure></li></ul><h5 id="slave-从服务器的配置"><a href="#slave-从服务器的配置" class="headerlink" title="slave 从服务器的配置"></a>slave 从服务器的配置</h5><ul><li><p>配置文件my.cnf的修改<br><code>vim /etc/my.cnf</code><br>在 <code>[mysqld]</code> 中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#备注：</span><br><span class="line">#server-id 服务器唯一标识，如果有多个从服务器，每个服务器的server-id不能重复，跟IP一样是唯一标识，如果你没设置server-id或者设置为0，则从服务器不会连接到主服务器。</span><br><span class="line">#relay-log 启动MySQL二进制日志，可以用来做数据备份和崩溃恢复，或主服务器挂掉了，将此从服务器作为其他从服务器的主服务器。</span><br><span class="line">#replicate-do-db 指定同步的数据库，如果复制多个数据库，重复设置这个选项即可。若在master端不指定binlog-do-db，则在slave端可用replication-do-db来过滤。</span><br><span class="line">#replicate-ignore-db 不需要同步的数据库，如果有多个数据库，重复设置这个选项即可。</span><br><span class="line">#其中需要注意的是，replicate-do-db和replicate-ignore-db为互斥选项，一般只需要一个即可。</span><br><span class="line"></span><br><span class="line">server-id=2</span><br><span class="line">relay-log=slave-relay-bin</span><br><span class="line">relay-log-index=slave-relay-bin.index</span><br><span class="line">#replicate-do-db=test</span><br></pre></td></tr></table></figure><p>退出保存重启</p></li><li><p>连接 master 主服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#备注：</span><br><span class="line">#master_host对应主服务器的IP地址。</span><br><span class="line">#master_port对应主服务器的端口。</span><br><span class="line">#master_log_file对应 show master status 显示的File列：master-bin.000001。</span><br><span class="line">#master_log_pos对应 show master status 显示的Position列：154。</span><br><span class="line"></span><br><span class="line">mysql&gt; change master to master_host=&apos;192.168.2.19&apos;,master_port=3306,master_user=&apos;masterbackup&apos;,master_password=&apos;12345678&apos;,master_log_file=&apos;master-bin.000001&apos;,master_log_pos=154;</span><br></pre></td></tr></table></figure></li><li><p>启动 slave 数据同步<br><code>mysql&gt; start slave;</code></p></li><li><p>停止 slave 数据同步（若有需要）<br><code>mysql&gt; stop slave;</code></p></li><li><p>查看 slave 信息<br><code>mysql&gt; show slave status\G;</code><br><code>Slave_IO_Running</code> 和 <code>Slave_SQL_Running</code> 都为 <code>yes</code>，则表示同步成功。</p></li></ul><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>在主服务器上登陆 mysql，且进入 test 数据库，创建 test 表，且插入一条数据<br>用数据库管理工具（nacicat 等）操作方便<br>在从服务器上登陆 mysql，且进入 test 数据库，查看 test 表 是有数据，证明同步数据成功。</p><h5 id="解决错误"><a href="#解决错误" class="headerlink" title="解决错误"></a>解决错误</h5><p>若在主从同步的过程中，出现其中一条语句同步失败报错了，则后面的语句也肯定不能同步成功了。<br>例如，主库有一条数据，而从库并没有这一条数据，然而，在主库执行了删除这一条数据的操作，那么从库没有这么一条数据就肯定删除不了，从而报错了。<br>在此时的从数据库的数据同步就失败了，因此后面的同步语句就无法继续执行。<br>这里提供的解决方法有两种</p><ul><li><p>在从数据库中，使用 <code>SET</code> 全局 <code>sql_slave_skip_counter</code> 来跳过事件，跳过这一个错误，然后执行从下一个事件组开始。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#在从数据库上操作</span><br><span class="line">mysql &gt; stop slave;</span><br><span class="line">mysql &gt; set global sql_slave_skip_counter=1;</span><br><span class="line">mysql &gt; start slave;</span><br></pre></td></tr></table></figure></li><li><p>在从数据库中，重新连上主数据库。这种操作会直接跳过中间的那些同步语句，可能会导致一些数据未同步过去的问题，但这种操作也是最后的绝招。最好就是令从数据库与主数据库的数据结构和数据都一致了之后，再来恢复主从同步的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#在从数据库上操作</span><br><span class="line"># master_log_file 和 master_log_pos 可能会不同，需要在主数据库中 show master status 来查看</span><br><span class="line"></span><br><span class="line">mysql &gt; stop slave;</span><br><span class="line">mysql &gt; change master to master_host=&apos;192.168.2.19&apos;,master_port=3306,master_user=&apos;masterbackup&apos;,master_password=&apos;12345678&apos;,master_log_file=&apos;master-bin.000001&apos;,master_log_pos=2050;</span><br><span class="line">mysql &gt; start slave;</span><br></pre></td></tr></table></figure></li></ul><p>mysql 数据库的主从同步就完成了，至于读写分离，我们可以通过程序来实现，简单的实现思想。<br>我们可以在主服务器创建一个数据库用户（出于安全，根据需求给予相应的权限）主要用于写操作，在程序中通过这一用户连接主数据库的只用于写操作而不用读操作。<br>在从服务器上创建一个数据库用户（出于安全，只给予读 <code>select</code> 的权限）主要用于读操作，在程序中通过这一用户连接从数据库即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大型网站为了软解大量的并发访问，除了在网站实现分布式负载均衡，远远不够.&lt;br&gt;到了数据业务层、数据访问层，如果还是传统的数据结构，&lt;br&gt;或者只是单单靠一台服务器来处理如此多的数据库连接操作，数据库必然会崩溃，特别是数据丢失的话，后果更是不堪设想.&lt;br&gt;利用主从数据库来实现读写分离，从而分担主数据库的压力.&lt;br&gt;在多个服务器上部署 mysql，将其中一台认为主数据库，而其他为从数据库，实现主从同步.&lt;br&gt;其中主数据库负责主动写的操作，而从数据库则只负责主动读的操作（slave 从数据库仍然会被动的进行写操作，为了保持数据一致性），&lt;br&gt;这样就可以很大程度上的避免数据丢失的问题，同时也可减少数据库的连接，减轻主数据库的负载.&lt;/p&gt;
&lt;p&gt;主从同步复制有以下几种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步复制：master 的变化，必须等待 slave-1,slave-2,…,slave-n 完成后才能返回。&lt;/li&gt;
&lt;li&gt;异步复制：master 只需要完成自己的数据库操作即可，至于 slaves 是否收到二进制日志，是否完成操作，不用关心。MYSQL 的默认设置。&lt;/li&gt;
&lt;li&gt;半同步复制：master 只保证 slaves 中的一个操作成功，就返回，其他 slave 不管。这个功能，是由 google 为 MYSQL 引入的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mysql 主从复制的思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置主服务器，即 msater，使之具备一下能力(主要接受用户的写操作，并且负责将二进制日志同步给从服务器)&lt;ul&gt;
&lt;li&gt;记录二进制日志&lt;/li&gt;
&lt;li&gt;为从服务提供一个用户(设置密码)，提高二进制日志同步得安全性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;配置从服务器，即 slave，使之具备一下能力(主要负责用户的读操作(分担主服务器的读写压力)，并且负责重放 master的 写操作，还能实现容灾能力，保证高可用)&lt;ul&gt;
&lt;li&gt;记录中继日志&lt;/li&gt;
&lt;li&gt;连接到 mysql 可以启动 slave 功能，并且设置 master 信息，通过配置信息，开启 IO_THREAD 和 SQL_THREAD 线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySql" scheme="https://blog.gotwo.top/categories/MySql/"/>
    
    
      <category term="mysql" scheme="https://blog.gotwo.top/tags/mysql/"/>
    
      <category term="slave" scheme="https://blog.gotwo.top/tags/slave/"/>
    
  </entry>
  
  <entry>
    <title>centos7 安装 mysql5.7</title>
    <link href="https://blog.gotwo.top/centos7-install-mysql57.html"/>
    <id>https://blog.gotwo.top/centos7-install-mysql57.html</id>
    <published>2020-07-04T14:36:41.000Z</published>
    <updated>2020-11-22T15:25:32.941Z</updated>
    
    <content type="html"><![CDATA[<h5 id="安装-mysql-server"><a href="#安装-mysql-server" class="headerlink" title="安装 mysql-server"></a>安装 mysql-server</h5><ul><li>下载并安装 mysql yum 源<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line">yum -y install mysql57-community-release-el7-10.noarch.rpm</span><br></pre></td></tr></table></figure></li></ul><p>运行查看可安装的mysql的命令：<code>yum repolist all| grep mysql</code><br>可以修改 yum 配置（<code>enabled=1</code> 想要安装哪个版本就在哪个版本的后面把 0 换成 1，因为默认是最新版，所以需要把最新版的 1 换成 0，5.7 的换为 1）<br>路径 <code>/etc/yum.repos.d/mysql-community.repo</code><br>这里下载的是 5.7 版本的源就不要修改了</p><ul><li>安装 mysql-server<br><code>yum -y install mysql-community-server</code></li></ul><a id="more"></a><h5 id="mysql-初始化安装的一些配置"><a href="#mysql-初始化安装的一些配置" class="headerlink" title="mysql 初始化安装的一些配置"></a>mysql 初始化安装的一些配置</h5><ul><li><p>启动 mysql-serer<br><code>systemctl start mysqld</code></p></li><li><p>开机自启<br><code>systemctl enable mysqld</code></p></li><li><p>查看是否启动成功，即是否存在 3306 端口<br><code>netstat -tnlp | grep 3306</code></p></li><li><p>查询 root 密码<br><code>grep &quot;password&quot; /var/log/mysqld.log</code></p></li><li><p>登录到 mysql<br><code>mysql -uroot -p</code></p></li><li><p>首次操作要求重置密码,必须大小写特殊字符组成<br><code>mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;新密码&#39;;</code></p></li><li><p>配置使用弱密码 (不想设置复杂的密码)<br>mysql 升级到 5.7 版本后，对密码进行了加强，默认密码策略要求密码必须是大小写字母数字特殊字母的组合，至少8位<br><code>mysql.user</code> 中的 <code>password</code> 字段修改为了 <code>authentication_string</code></p><p>增加了密码验证插件 查看当前密码规则 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;validate_password%&apos;;  </span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">| Variable_name                        | Value  |</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">| validate_password_check_user_name    | OFF    |</span><br><span class="line">| validate_password_dictionary_file    |        |</span><br><span class="line">| validate_password_length             | 8      | 密码最小长度</span><br><span class="line">| validate_password_mixed_case_count   | 1      | 密码大写小写混合个数</span><br><span class="line">| validate_password_number_count       | 1      | 密码数字个数</span><br><span class="line">| validate_password_policy             | MEDIUM | 密码检查等级</span><br><span class="line">| validate_password_special_char_count | 1      | 密码特殊字符个数</span><br><span class="line">+--------------------------------------+--------+</span><br></pre></td></tr></table></figure><p>解决办法有两种<br>一种是改验证规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global validate_password_policy=0;</span><br><span class="line">mysql&gt; set global validate_password_mixed_case_count=0;</span><br><span class="line">mysql&gt; set global validate_password_number_count=3;</span><br><span class="line">mysql&gt; set global validate_password_special_char_count=0;</span><br></pre></td></tr></table></figure></li></ul><p>  二是直接卸载这个密码验证插件<br>  <code>mysql&gt; uninstall plugin validate_password;</code></p><ul><li><p>授权远程访问 % 表示所有主机都可以访问<br><code>mysql&gt; grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;自己的密码&#39; with grant option;</code></p></li><li><p>刷新权限信息<br><code>mysql&gt; flush privileges;</code></p></li></ul><blockquote><p>最后要注意防火墙开放3306端口 不然链接不上</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;安装-mysql-server&quot;&gt;&lt;a href=&quot;#安装-mysql-server&quot; class=&quot;headerlink&quot; title=&quot;安装 mysql-server&quot;&gt;&lt;/a&gt;安装 mysql-server&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;下载并安装 mysql yum 源&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum -y install mysql57-community-release-el7-10.noarch.rpm&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;运行查看可安装的mysql的命令：&lt;code&gt;yum repolist all| grep mysql&lt;/code&gt;&lt;br&gt;可以修改 yum 配置（&lt;code&gt;enabled=1&lt;/code&gt; 想要安装哪个版本就在哪个版本的后面把 0 换成 1，因为默认是最新版，所以需要把最新版的 1 换成 0，5.7 的换为 1）&lt;br&gt;路径 &lt;code&gt;/etc/yum.repos.d/mysql-community.repo&lt;/code&gt;&lt;br&gt;这里下载的是 5.7 版本的源就不要修改了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装 mysql-server&lt;br&gt;&lt;code&gt;yum -y install mysql-community-server&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySql" scheme="https://blog.gotwo.top/categories/MySql/"/>
    
    
      <category term="mysql" scheme="https://blog.gotwo.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Explain 执行计划</title>
    <link href="https://blog.gotwo.top/mysql-explain.html"/>
    <id>https://blog.gotwo.top/mysql-explain.html</id>
    <published>2020-06-16T18:30:20.000Z</published>
    <updated>2020-11-22T15:25:32.941Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Explain有什么用"><a href="#Explain有什么用" class="headerlink" title="Explain有什么用"></a><strong>Explain有什么用</strong></h4><p>当<code>Explain</code>与<code>SQL</code>语句一起使用时，<code>MySQL</code>会显示来自优化器关于<code>SQL</code>执行的信息。<br>也就是说，<code>MySQL</code>解释了它将如何处理该语句，包括如何连接表以及什么顺序连接表等。</p><ul><li>表的加载顺序</li><li><code>sql</code>的查询类型</li><li>可能用到哪些索引，哪些索引又被实际使用</li><li>表与表之间的引用关系</li><li>一个表中有多少行被优化器查询</li></ul><a id="more"></a><h4 id="Explain有哪些信息"><a href="#Explain有哪些信息" class="headerlink" title="Explain有哪些信息"></a><strong>Explain有哪些信息</strong></h4><p>Explain执行计划包含字段信息如下：<br>分别是 <code>id</code>、<code>select_type</code>、<code>table</code>、<code>partitions</code>、<code>type</code>、<code>possible_keys</code>、<code>key</code>、<code>key_len</code>、<code>ref</code>、<code>rows</code>、<code>filtered</code>、<code>Extra</code>12个字段。</p><p>下边会结合具体的<code>SQL</code>示例，详细的解读每个字段以及每个字段中不同参数的含义，以下所有示例数据库版本为 <code>MySQL.5.7.18</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select version();</span><br><span class="line">+-----------+</span><br><span class="line">| version() |</span><br><span class="line">+-----------+</span><br><span class="line">| 5.7.18    |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure></p><p>创建三张表 <code>one</code>、<code>two</code>、<code>three</code>，<br>表之间的关系 <code>one.two_id = two.two_id AND two.three_id = three.three_id</code></p><h4 id="Explain执行计划详解"><a href="#Explain执行计划详解" class="headerlink" title="Explain执行计划详解"></a><strong>Explain执行计划详解</strong></h4><h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>id: 表示查询中执行select子句或者操作表的顺序，<strong><code>id</code>的值越大，代表优先级越高，越先执行</strong>。id大致会出现 3种情况：</p><ul><li><p>id相同<br>看到三条记录的<code>id</code>都相同，可以理解成这三个表为一组，具有同样的优先级，执行顺序由上而下，具体顺序由优化器决定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM one o,two t, three r WHERE o.two_id = t.two_id AND t.three_id = r.three_id;</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+----------------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref                  | rows | filtered | Extra                                              |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+----------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | ALL    | NULL          | NULL    | NULL    | NULL                 |    2 |      100 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL                 |    2 |       50 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">|  1 | SIMPLE      | r     | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xin-slave.t.three_id |    1 |      100 | NULL                                               |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+----------------------------------------------------+</span><br></pre></td></tr></table></figure></li><li><p>id不同<br>如果我们的<code>SQL</code>中存在子查询，那么<code>id</code>的序号会递增，id值越大优先级越高，越先被执行 。<br>当三个表依次嵌套，发现最里层的子查询<code>id</code>最大，最先执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select * from one o where o.two_id = (select t.two_id from two t where t.three_id = (select r.three_id  from three r where r.three_name=&apos;我是第三表2&apos;));</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | o     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |       50 | Using where |</span><br><span class="line">|  2 | SUBQUERY    | t     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |       50 | Using where |</span><br><span class="line">|  3 | SUBQUERY    | r     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |       50 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure></li><li><p>以上两种同时存在<br>将上边的<code>SQL</code>稍微修改一下，增加一个子查询，发现<code>id</code>的以上两种同时存在。<br>相同<code>id</code>划分为一组，这样就有三个组，同组的从上往下顺序执行，不同组<code>id</code>值越大，优先级越高，越先执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  EXPLAIN select * from one o where o.two_id = (select t.two_id from two t where t.three_id = (select r.three_id  from three r where r.three_name=&apos;我是第三表2&apos;)) AND o.one_id in(select one_id from one where o.one_name=&quot;我是第一表2&quot;);</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref                | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | o     | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL               |    2 |       50 | Using where |</span><br><span class="line">|  1 | PRIMARY     | one   | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xin-slave.o.one_id |    1 |      100 | Using index |</span><br><span class="line">|  2 | SUBQUERY    | t     | NULL       | ALL    | NULL          | NULL    | NULL    | NULL               |    2 |       50 | Using where |</span><br><span class="line">|  3 | SUBQUERY    | r     | NULL       | ALL    | NULL          | NULL    | NULL    | NULL               |    2 |       50 | Using where |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+------+----------+-------------+</span><br></pre></td></tr></table></figure></li></ul><h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h5><p><code>select_type</code>： 表示<code>select</code>查询的类型，主要是用于区分各种复杂的查询，例如：普通查询、联合查询、子查询等。</p><ul><li>SIMPLE<br><code>SIMPLE</code>：表示最简单的<code>select</code>查询语句，也就是在查询中不包含子查询或者<code>union</code>交并差集等操作。</li><li><p>PRIMARY<br><code>PRIMARY</code>：当查询语句中包含任何复杂的子部分，最外层查询则被标记为<code>PRIMARY</code>。</p></li><li><p>SUBQUERY<br><code>SUBQUERY</code>：当<code>select</code>或<code>where</code>列表中包含了子查询，该子查询被标记为：<code>SUBQUERY</code>。</p></li><li><p>DERIVED<br><code>DERIVED</code>：表示包含在<code>from</code>子句中的子查询的<code>select</code>，在我们的<code>from</code>列表中包含的子查询会被标记为<code>derived</code>。</p></li><li><p>UNION<br><code>UNION</code>：如果<code>union</code>后边又出现的<code>select</code>语句，则会被标记为<code>union</code>；<br>若<code>union</code>包含在<code>from</code>子句的子查询中，外层<code>select</code>将被标记为<code>derived</code>。</p></li><li><p>UNION RESULT<br><code>UNION RESULT</code>：代表从<code>union</code>的临时表中读取数据，<br>而<code>table</code>列的<code>&lt;union1,4&gt;</code>表示用第一个和第四个<code>select</code>的结果进行<code>union</code>操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select t.two_name, ( select one.one_id from one) o from (select two_id,two_name from two where two_name =&apos;&apos;) t  union (select r.three_name,r.three_id from three r);</span><br><span class="line"></span><br><span class="line">+------+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class="line">| id   | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |</span><br><span class="line">+------+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class="line">|    1 | PRIMARY      | two        | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |    2 |       50 | Using where     |</span><br><span class="line">|    2 | SUBQUERY     | one        | NULL       | index | NULL          | PRIMARY | 4       | NULL |    2 |      100 | Using index     |</span><br><span class="line">|    4 | UNION        | r          | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |    2 |      100 | NULL            |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,4&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL | NULL     | Using temporary |</span><br><span class="line">+------+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br></pre></td></tr></table></figure></li></ul><h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><p>查询的表名，并不一定是真实存在的表，有别名显示别名，也可能为临时表，例如上边的<code>DERIVED</code>、<code>&lt;union1,4&gt;</code>等。</p><h5 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h5><p>查询时匹配到的分区信息，对于非分区表值为<code>NULL</code>，当查询的是分区表时，<code>partitions</code>显示分区表命中的分区情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+----------------+---------------------------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table          | partitions                      | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+----------------+---------------------------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | one            | p201801,p201802,p201803,p300012 | index | NULL          | PRIMARY | 9       | NULL |    3 |      100 | Using index |</span><br><span class="line">+----+-------------+----------------+---------------------------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure></p><h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p><code>type</code>：查询使用了何种类型，它在<code>SQL</code>优化中是一个非常重要的指标，<br>以下性能从好到坏依次是：<br><code>system</code> &gt; <code>const</code> &gt; <code>eq_ref</code> &gt; <code>ref</code> &gt; <code>ref_or_null</code> &gt; <code>index_merge</code> &gt; <code>unique_subquery</code> &gt; <code>index_subquery</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>ALL</code></p><ul><li><p>system<br><code>system</code>： 当表仅有一行记录时(系统表)，数据量很少，往往不需要进行磁盘IO，速度非常快。</p></li><li><p>const<br><code>const</code>：表示查询时命中<code>primary key</code>主键或者<code>unique</code>唯一索引，或者被连接的部分是一个常量(<code>const</code>)值。<br>这类扫描效率极高，返回数据量少，速度非常快。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from three where three_id=1;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | three | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |      100 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br></pre></td></tr></table></figure></li><li><p>eq_ref<br><code>eq_ref</code>：查询时命中主键<code>primary key</code>或者<code>unique key</code>索引，<code>type</code>就是<code>eq_ref</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select o.one_name from one o ,two t where o.one_id = t.two_id ; </span><br><span class="line">+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key      | key_len | ref                | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | index  | PRIMARY       | idx_name | 768     | NULL               |    2 |      100 | Using index |</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | eq_ref | PRIMARY       | PRIMARY  | 4       | xin-slave.o.one_id |    1 |      100 | Using index |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-------------+</span><br></pre></td></tr></table></figure></li><li><p>ref<br><code>ref</code>：区别于<code>eq_ref</code>，<code>ref</code>表示使用非唯一性索引，会找到很多个符合条件的行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select o.one_id from one o where o.one_name = &quot;xin&quot; ; </span><br><span class="line">+--------+</span><br><span class="line">| one_id |</span><br><span class="line">+--------+</span><br><span class="line">|      1 |</span><br><span class="line">|      3 |</span><br><span class="line">+--------+</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN select o.one_id from one o where o.one_name = &quot;xin&quot; ; </span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | ref  | idx_name      | idx_name | 768     | const |    1 |      100 | Using index |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span><br></pre></td></tr></table></figure></li><li><p>ref_or_null<br><code>ref_or_null</code>：这种连接类型类似于 <code>ref</code>，区别在于<code>MySQL</code>会额外搜索包含<code>NULL</code>值的行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select o.one_id from one o where o.one_name = &quot;xin&quot; OR o.one_name IS NULL; </span><br><span class="line">+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line">| id | select_type | table | partitions | type        | possible_keys | key      | key_len | ref   | rows | filtered | Extra                    |</span><br><span class="line">+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | ref_or_null | idx_name      | idx_name | 768     | const |    3 |      100 | Using where; Using index |</span><br><span class="line">+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br></pre></td></tr></table></figure></li><li><p>index_merge<br><code>index_merge</code>：使用了索引合并优化方法，查询使用了两个以上的索引。<br>下边示例中同时使用到主键<code>one_id</code>和 字段<code>one_name</code>的<code>idx_name</code>索引 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select * from one o where o.one_id &gt;1 and o.one_name =&apos;xin&apos;; </span><br><span class="line">+----+-------------+-------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type        | possible_keys    | key              | key_len | ref  | rows | filtered | Extra                                          |</span><br><span class="line">+----+-------------+-------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | index_merge | PRIMARY,idx_name | idx_name,PRIMARY | 772,4   | NULL |    1 |      100 | Using intersect(idx_name,PRIMARY); Using where |</span><br><span class="line">+----+-------------+-------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+</span><br></pre></td></tr></table></figure></li><li><p>unique_subquery<br><code>unique_subquery</code>：替换下面的<code>IN</code>子查询，子查询返回不重复的集合。<br><code>value IN (SELECT primary_key FROM single_table WHERE some_expr)</code></p></li><li><p>index_subquery<br><code>index_subquery</code>：区别于<code>unique_subquery</code>，用于非唯一索引，可以返回重复值。<br><code>value IN (SELECT key_column FROM single_table WHERE some_expr)</code></p></li><li><p>range<br><code>range</code>：使用索引选择行，仅检索给定范围内的行。简单点说就是针对一个有索引的字段，给定范围检索数据。<br>在<code>where</code>语句中使用<code>bettween...and</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>in</code>等条件查询<code>type</code>都是<code>range</code>。<br>举个栗子：<code>three</code>表中<code>three_id</code>为唯一主键，<code>user_id</code>普通字段未建索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from three where three_id BETWEEN 2 AND 3;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | three | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    1 |      100 | Using where |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure></li></ul><p>从结果中看到只有对设置了索引的字段，做范围检索<code>type</code>才是<code>range</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from three where user_id BETWEEN 2 AND 3;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | three | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure></p><ul><li><p>index<br><code>index</code>：<code>Index</code>与<code>ALL</code>其实都是读全表，区别在于<code>index</code>是遍历索引树读取，而<code>ALL</code>是从硬盘中读取。<br>下边示例：<code>three_id</code>为主键，不带<code>where</code>条件全表查询，<code>type</code>结果为<code>index</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT three_id from three ;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | three | NULL       | index | NULL          | PRIMARY | 4       | NULL |    1 |      100 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure></li><li><p>ALL<br><code>ALL</code>：将遍历全表以找到匹配的行，性能最差。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from two ;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | two   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |      100 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br></pre></td></tr></table></figure></li></ul><h5 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h5><p><code>possible_keys</code>：表示在<code>MySQL</code>中通过哪些索引，能让我们在表中找到想要的记录，一旦查询涉及到的某个字段上存在索引，<br>则索引将被列出，但这个索引并不定一会是最终查询数据时所被用到的索引。具体请参考上边的例子。</p><h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><p><code>key</code>：区别于<code>possible_keys</code>，<code>key</code>是查询中实际使用到的索引，若没有使用索引，显示为<code>NULL</code>。具体请参考上边的例子。</p><blockquote><p>当type为index_merge时，可能会显示多个索引。</p></blockquote><h5 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h5><p><code>key_len</code>：表示查询用到的索引长度（字节数），原则上长度越短越好 。</p><ul><li>单列索引，那么需要将整个索引长度算进去；</li><li>多列索引，不是所有列都能用到，需要计算查询中实际用到的列。<blockquote><p>注意：key_len只计算where条件中用到的索引长度，而排序和分组即便是用到了索引，也不会计算到key_len中。</p></blockquote></li></ul><h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><p><code>ref</code>：常见的有：<code>const</code>，<code>func</code>，<code>null</code>，字段名。</p><ul><li>当使用常量等值查询，显示<code>const</code>，</li><li>当关联查询时，会显示相应关联表的关联字段</li><li>如果查询条件使用了表达式、函数，或者条件列发生内部隐式转换，可能显示为<code>func</code></li><li>其他情况<code>null</code></li></ul><h5 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h5><p><code>rows</code>：以表的统计信息和索引使用情况，估算要找到我们所需的记录，需要读取的行数。<br>这是评估<code>SQL</code>性能的一个比较重要的数据，<code>mysql</code>需要扫描的行数，很直观的显示<code>SQL</code>性能的好坏，一般情况下<code>rows</code>值越小越好。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from three;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | three | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |      100 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br></pre></td></tr></table></figure></p><h5 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h5><p><code>filtered</code>这个是一个百分比的值，表里符合条件的记录数的百分比。<br>简单点说，这个字段表示存储引擎返回的数据在经过过滤后，剩下满足条件的记录数量的比例。</p><p>在<code>MySQL.5.7</code>版本以前想要显示<code>filtered</code>需要使用<code>explain extended</code>命令。<br><code>MySQL.5.7</code>后，默认<code>explain</code>直接显示<code>partitions</code>和<code>filtered</code>的信息。</p><h5 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h5><p><code>Extra</code>：不适合在其他列中显示的信息，<code>Explain</code>中的很多额外的信息会在<code>Extra</code>字段显示。</p><ul><li><p>Using index<br><code>Using index</code>：我们在相应的<code>select</code>操作中使用了覆盖索引，通俗一点讲就是查询的列被索引覆盖，<br>使用到覆盖索引查询速度会非常快，<code>SQl</code>优化中理想的状态。<br>什么又是覆盖索引?<br>一条<code>SQL</code>只需要通过索引就可以返回，我们所需要查询的数据（一个或几个字段），而不必通过二级索引，<br>查到主键之后再通过主键查询整行数据（<code>select *</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- one_id表为主键</span><br><span class="line">mysql&gt; EXPLAIN SELECT one_id from one ;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | one   | NULL       | index | NULL          | idx_two_id | 5       | NULL |    3 |      100 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+</span><br><span class="line">```        </span><br><span class="line">注意：想要使用到覆盖索引，我们在`select`时只取出需要的字段，不可`select *`，而且该字段建了索引。    </span><br><span class="line">```mysql</span><br><span class="line">mysql&gt; EXPLAIN SELECT * from one ;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | one   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |      100 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br></pre></td></tr></table></figure></li><li><p>Using where<br><code>Using where</code>：查询时未找到可用的索引，进而通过<code>where</code>条件过滤获取所需数据，<br>但要注意的是并不是所有带<code>where</code>语句的查询都会显示<code>Using where</code>。<br>下边示例<code>create_time</code>并未用到索引，<code>type</code>为<code>ALL</code>，即<code>MySQL</code>通过全表扫描后再按<code>where</code>条件筛选数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one where create_time =&apos;2020-05-18&apos;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | one   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure></li><li><p>Using temporary<br><code>Using temporary</code>：表示查询后结果需要使用临时表来存储，一般在排序或者分组查询时用到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one where one_id in (1,2) group by one_name;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | one   | NULL       | range| NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where; Using temporary; Using filesort |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure></li><li><p>Using filesort<br><code>Using filesort</code>：表示无法利用索引完成的排序操作，也就是<code>ORDER BY</code>的字段没有索引，通常这样的<code>SQL</code>都是需要优化的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_id from one  ORDER BY create_time;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | one   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |      100 | Using filesort |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br></pre></td></tr></table></figure></li></ul><p>如果<code>ORDER BY</code>字段有索引就会用到覆盖索引，相比执行速度快很多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_id from one  ORDER BY one_id;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | one   | NULL       | index | NULL          | PRIMARY | 4       | NULL |    3 |      100 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure></p><ul><li>Using join buffer<br><code>Using join buffer</code>：在我们联表查询的时候，如果表的连接条件没有用到索引，需要有一个连接缓冲区来存储中间结果。<br>先看一下有索引的情况：连接条件<code>one_name</code>、<code>two_name</code>都用到索引。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one o,two t where o.one_name = t.two_name;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+----------------------+------+----------+--------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref                  | rows | filtered | Extra                    |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+----------------------+------+----------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | index | idx_name      | idx_name | 768     | NULL                 |    3 |      100 | Using where; Using index |</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | ref   | idx_name      | idx_name | 768     | xin-slave.o.one_name |    1 |      100 | Using index              |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+----------------------+------+----------+--------------------------+</span><br></pre></td></tr></table></figure></li></ul><p>接下来删掉 连接条件<code>one_name</code>、<code>two_name</code>的字段索引。<br>发现<code>Extra</code>列变成<code>Using join buffer</code>，<code>type</code>均为全表扫描，这也是<code>SQL</code>优化中需要注意的地方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one o,two t where o.one_name = t.two_name;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |      100 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><br></pre></td></tr></table></figure></p><ul><li><p>Impossible where<br><code>Impossible where</code>：表示在我们用不太正确的<code>where</code>语句，导致没有符合条件的行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one WHERE 1=2;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra            |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | NULL     | Impossible WHERE |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span><br></pre></td></tr></table></figure></li><li><p>No tables used<br><code>No tables used</code>：我们的查询语句中没有<code>FROM</code>子句，或者有<code>FROM DUAL</code>子句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select now();</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | NULL     | No tables used |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br></pre></td></tr></table></figure></li></ul><p><code>Extra</code> 列的信息非常非常多，这里就不再一一列举了，详见<code>MySQL</code>官方文档 ：<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_index_merge" target="_blank" rel="noopener">https://dev.mysql.com/doc/ref…</a>   </p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>重点看的几列：</p><ul><li><p><code>possible_keys</code>：可能可以利用的索引的名字。这里的索引名字是创建索引时指定的索引昵称；<br>如果索引没有昵称，则默认显示的是索引中第一个列的名字（在本例中，它是“firstname”）。<br>默认索引名字的含义往往不是很明显。</p></li><li><p><code>key</code>：它显示了<code>MySQL</code>实际使用的索引的名字。如果它为空（或<code>NULL</code>），则<code>MySQL</code>不使用索引。</p></li><li><p><code>key_len</code>：索引中被使用部分的长度，以字节计。</p></li><li><p><code>ref</code>：列出是通过常量（<code>const</code>），还是某个表的某个字段（如果是<code>join</code>）来过滤（通过<code>key</code>）的。</p></li><li><p><code>rows</code>：<code>MySQL</code>所认为的它在找到正确的结果之前必须扫描的记录数。显然，这里最理想的数字就是1。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Explain有什么用&quot;&gt;&lt;a href=&quot;#Explain有什么用&quot; class=&quot;headerlink&quot; title=&quot;Explain有什么用&quot;&gt;&lt;/a&gt;&lt;strong&gt;Explain有什么用&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;当&lt;code&gt;Explain&lt;/code&gt;与&lt;code&gt;SQL&lt;/code&gt;语句一起使用时，&lt;code&gt;MySQL&lt;/code&gt;会显示来自优化器关于&lt;code&gt;SQL&lt;/code&gt;执行的信息。&lt;br&gt;也就是说，&lt;code&gt;MySQL&lt;/code&gt;解释了它将如何处理该语句，包括如何连接表以及什么顺序连接表等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表的加载顺序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sql&lt;/code&gt;的查询类型&lt;/li&gt;
&lt;li&gt;可能用到哪些索引，哪些索引又被实际使用&lt;/li&gt;
&lt;li&gt;表与表之间的引用关系&lt;/li&gt;
&lt;li&gt;一个表中有多少行被优化器查询&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySql" scheme="https://blog.gotwo.top/categories/MySql/"/>
    
    
      <category term="mysql" scheme="https://blog.gotwo.top/tags/mysql/"/>
    
      <category term="explain" scheme="https://blog.gotwo.top/tags/explain/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7 安装 Docker 和 Docker-compose</title>
    <link href="https://blog.gotwo.top/centos7-docker.html"/>
    <id>https://blog.gotwo.top/centos7-docker.html</id>
    <published>2020-05-30T15:26:43.000Z</published>
    <updated>2020-11-22T15:25:32.941Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>安装 Docker</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 安装依赖</span><br><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br><span class="line"></span><br><span class="line"># 添加docker下载仓库（由于网络原因，这里添加的是阿里云镜像）</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装docker-ce</span><br><span class="line">sudo yum install docker-ce</span><br><span class="line"></span><br><span class="line"># 开机自启</span><br><span class="line">sudo systemctl enable docker</span><br><span class="line"># 启动docker-ce</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"># 验证</span><br><span class="line">sudo docker --version</span><br><span class="line"></span><br><span class="line"># 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。</span><br><span class="line"># 而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。</span><br><span class="line"># 可将非 root 用户 加入 docker 组：（$USER 当前用户）</span><br><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><ul><li><strong>安装 docker-compose</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 下载 docker-compose （有可能比较慢 可下载好上传） 版本 1.25.5</span><br><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.25.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 修改权限</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 验证</span><br><span class="line">sudo docker-compose --version</span><br></pre></td></tr></table></figure><p>注意需要使用 root 账户或可以使用 sudo 的账户</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;安装 Docker&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span
      
    
    </summary>
    
      <category term="Linux" scheme="https://blog.gotwo.top/categories/Linux/"/>
    
    
      <category term="centos" scheme="https://blog.gotwo.top/tags/centos/"/>
    
      <category term="docker" scheme="https://blog.gotwo.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>limit分页查询性能问题</title>
    <link href="https://blog.gotwo.top/mysql-limit.html"/>
    <id>https://blog.gotwo.top/mysql-limit.html</id>
    <published>2020-01-04T14:48:54.000Z</published>
    <updated>2020-11-22T15:25:32.941Z</updated>
    
    <content type="html"><![CDATA[<p>分页查询时，我们会在 <code>LIMIT</code> 后面传两个参数，一个是偏移量（<code>offset</code>），一个是获取的条数（<code>limit</code>）。当偏移量很小时，查询速度很快，但是当 <code>offset</code> 很大时，查询速度就会变慢。</p><p>MySQL Limit 语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset</span><br></pre></td></tr></table></figure><p>假设有一张 300w 条数据的表，对其进行分页查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * from tbl limit 1, 10// 31.6ms</span><br><span class="line">select * from tbl limit 10, 10// 34.9ms</span><br><span class="line">select * from tbl limit 100, 10// 35.6ms</span><br><span class="line">select * from tbl limit 1000, 10// 38.3ms</span><br><span class="line">select * from tbl limit 10000, 10// 5561ms</span><br><span class="line">select * from tbl limit 100000, 10// 60.6s</span><br><span class="line">select * from tbl limit 1000000, 10// 272.3s</span><br></pre></td></tr></table></figure><p>LIMIT分页查询的时间与偏移量值成正比。当偏移量越大时，查询时间越长。这种情况，会随着业务的增加，数据的增多，会越发的明显。那么，如何优化这种情况呢？答案是，覆盖索引。</p><a id="more"></a><p><strong>优化思路</strong></p><p>对于LIMIT分页查询的性能优化，主要思路是利用覆盖索引字段定位数据，然后再取出内容。</p><ul><li><h4 id="子查询分页方式"><a href="#子查询分页方式" class="headerlink" title="子查询分页方式"></a>子查询分页方式</h4></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tbl</span><br><span class="line">WHERE id &gt;= (SELECT id FROM tbl limit 100000, 1)</span><br><span class="line">LIMIT 20  // 55ms</span><br></pre></td></tr></table></figure><p>子查询分页方式，首先通过子查询和覆盖索引定位到起始位置ID，然后再取所需条数的数据。</p><p>缺点是，不适用于结果集不以ID连续自增的分页场景。在复杂分页场景，往往需要通过过滤条件，筛选到符合条件的ID，此时的ID是离散且不连续的。如果使用上述的方式，并不能筛选出目标数据。</p><p><strong>改造版</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT t1.* FROM tbl t1</span><br><span class="line">WHERE t1.id in (SELECT t2.id from (SELECT id FROM tbl limit 100000, 10) as t2)  // 53.8ms</span><br></pre></td></tr></table></figure><p>查询效率很高。但是，这种写法比较繁琐。我们可以使用下面的  <code>join</code>  分页方式，达到相同的优化效果。实际上，两者的原理是相同的。</p><ul><li><h4 id="join-分页方式"><a href="#join-分页方式" class="headerlink" title="join 分页方式"></a>join 分页方式</h4></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tbl t1 </span><br><span class="line">JOIN (SELECT id from tbl WHERE status=1 </span><br><span class="line">limit 100000, 10) t2</span><br><span class="line">ON t1.id = t2.id  // 53.3 ms</span><br></pre></td></tr></table></figure><p>这条SQL是，通过自连接与<code>join</code>定位到目标 <code>ids</code>，然后再将数据取出。在定位目标 <code>ids</code>时，由于 <code>SELECT</code>的元素只有主键 <code>ID</code>，且<code>status</code> 存在索引，因此MySQL只需在索引中，就能定位到目标 <code>ids</code>，不用在数据文件上进行查找。因而，查询效率非常高。</p><h4 id="覆盖索引（Cover-Index）"><a href="#覆盖索引（Cover-Index）" class="headerlink" title="覆盖索引（Cover Index）"></a>覆盖索引（Cover Index）</h4><blockquote><p>如果索引包含所有满足查询需要的数据的索引成为覆盖索引(Covering Index)，也就是平时所说的不需要回表操作。</p></blockquote><p>简单的说，覆盖索引覆盖所有需要查询的字段（大于或等于所查询的字段）。MySQL可以通过索引获取查询数据，因而不需要读取数据行。</p><p><strong>覆盖索引的好处：</strong></p><ul><li>索引大小远小于数据行大小。因而，如果只读取索引，则能极大减少对数据访问量。</li><li>索引按顺序储存。对于IO密集型的范围查询会比随机从磁盘读取每一行数据的IO要少。</li><li>避免对主键索引的二次查询。二级索引的叶子节点包含了主键的值，如果二级索引包含所要查询的值，则能避免二次查询主键索引（聚簇索引，聚簇索引既存储了索引，也储存了值）。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过利用覆盖索引，能极大的优化了Limit分页查询的效率。在真正的实践中，除了使用覆盖索引，优化查询速度外，我们还可以使用 Redis 缓存，将热点数据进行缓存储存。</p><p>也可以根据应用场景来选择限制分页，即在不影响阅读体验的前提下，只允许用户可以查看前几千条的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分页查询时，我们会在 &lt;code&gt;LIMIT&lt;/code&gt; 后面传两个参数，一个是偏移量（&lt;code&gt;offset&lt;/code&gt;），一个是获取的条数（&lt;code&gt;limit&lt;/code&gt;）。当偏移量很小时，查询速度很快，但是当 &lt;code&gt;offset&lt;/code&gt; 很大时，查询速度就会变慢。&lt;/p&gt;
&lt;p&gt;MySQL Limit 语法格式：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;假设有一张 300w 条数据的表，对其进行分页查询。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select * from tbl limit 1, 10		// 31.6ms&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from tbl limit 10, 10		// 34.9ms&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from tbl limit 100, 10		// 35.6ms&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from tbl limit 1000, 10	// 38.3ms&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from tbl limit 10000, 10	// 5561ms&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from tbl limit 100000, 10	// 60.6s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from tbl limit 1000000, 10	// 272.3s&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;LIMIT分页查询的时间与偏移量值成正比。当偏移量越大时，查询时间越长。这种情况，会随着业务的增加，数据的增多，会越发的明显。那么，如何优化这种情况呢？答案是，覆盖索引。&lt;/p&gt;
    
    </summary>
    
      <category term="MySql" scheme="https://blog.gotwo.top/categories/MySql/"/>
    
    
      <category term="mysql" scheme="https://blog.gotwo.top/tags/mysql/"/>
    
      <category term="limit" scheme="https://blog.gotwo.top/tags/limit/"/>
    
  </entry>
  
  <entry>
    <title>修改 PhpStorm 的默认 PHP 版本语法为 7.0+</title>
    <link href="https://blog.gotwo.top/phpstorm-php-lang-level.html"/>
    <id>https://blog.gotwo.top/phpstorm-php-lang-level.html</id>
    <published>2019-11-28T09:20:02.000Z</published>
    <updated>2020-11-22T15:25:32.945Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中使用 PHP7 新特性时 PHPStorm 出现了红色波浪线错误，鼠标移上去看，提示 <code>Coalesce operator is available in PHP 7 Only</code>，这明显不是代码错误，项目基于 PHP7.0+的，有点强迫症，必须把这个给干掉<br><a id="more"></a><br>首先自己的机子上的 PHP 版本是 7.3.8 的，排除安装的 PHP 版本过低的问题<br>查了一下发现 PHPStorm 默认支持的 PHP 版本语法问题<br>通过在偏好设置中查看发现默认是 PHP5.6 ，修改为 PHP7.+ 即可<br>在 <code>Setting -&gt; Languagers &amp; Framework -&gt; PHP</code> 可看到 <code>PHP language level</code> 是 5.6 的<br>但状态时不可编辑的，是因为 PhpStorm 自动开启了 Composer 配置文件同步的机制，只需要关闭就可以编辑了<br>在 <code>Setting -&gt; Languagers &amp; Framework -&gt; PHP -&gt; Composer -&gt; Synchronize IDE Setting with composer.json</code> 默认勾选了，取消勾选 然后 Apple 应用<br>这时候 <code>Setting -&gt; Languagers &amp; Framework -&gt; PHP</code> 的 <code>PHP language level</code> 可以编辑了 选一个 PHP7.+ 的 选好 Apply 并点击 OK 保存</p><p>这就修改成功了<br>红色波浪错误不见了，看着舒服多了</p><p>比较懒 就不上图了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目中使用 PHP7 新特性时 PHPStorm 出现了红色波浪线错误，鼠标移上去看，提示 &lt;code&gt;Coalesce operator is available in PHP 7 Only&lt;/code&gt;，这明显不是代码错误，项目基于 PHP7.0+的，有点强迫症，必须把这个给干掉&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://blog.gotwo.top/categories/PHP/"/>
    
    
      <category term="phpstorm" scheme="https://blog.gotwo.top/tags/phpstorm/"/>
    
  </entry>
  
  <entry>
    <title>使用 PHP 连接 docker 容器中的 MySQL 、 Redis 时 报错：Connection refused</title>
    <link href="https://blog.gotwo.top/docker-connection-refused.html"/>
    <id>https://blog.gotwo.top/docker-connection-refused.html</id>
    <published>2019-11-27T09:39:23.000Z</published>
    <updated>2020-11-22T15:25:32.941Z</updated>
    
    <content type="html"><![CDATA[<p>环境时基于 docker-compose 管理的 PHP 和 MySQL 服务<br>使用 PHP 连接 docker 容器中的 MySQL 和 Redis 时，报错：Connection refused，也就是在代码中使用 MySql Redis 会报错<br><a id="more"></a><br>连接 MySQL 测试代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $pdo = <span class="keyword">new</span> PDO(<span class="string">'mysql:dbname=test;host=127.0.0.1;charset=utf8mb4;port=3306'</span>, <span class="string">'root'</span>, <span class="string">'123456'</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Connection to server sucessfully"</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span>(PDOException $pe) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $pe-&gt;getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错</p><p><code>SQLSTATE[HY000] [2002] Connection refused</code></p><p>连接 Redis 测试代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $redis = <span class="keyword">new</span> Redis();</span><br><span class="line">    $redis-&gt;connect(<span class="string">'127.0.0.1'</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Connection to server sucessfully"</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span>(<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错</p><p><code>Connection refused</code></p><p>但是在宿主机用 Navicat 可以连接 MySql 各种操作都没问题，用 RedisDesktopManager 连接 Redis 也没问题</p><p>后来在网上找到了原因<br>主要是对 Docker 容器的隔离机制理解不够，其实每个容器之间都是隔离的，有相互依赖的服务，需要进行显示的关联，比如使用选项 –link<br>简单来说，容器之间相互隔绝，在进行了端口映射之后，宿主机可以通过 127.0.0.1:6379 访问 Redis ，127.0.0.1:3306 访问 MySql ，但 PHP 容器不行</p><p><strong>测试连接 MySQL 的代码其实是运行在 PHP 对应的容器里，而 MySQL 服务是在它自己对应的容器里，当我们的 host 填写 127.0.0.1 时候，其实对应的是 PHP 容器里面，所以不可能找到对应的服务，从而引起上面拒绝连接的错误。Redis 同理。</strong></p><ul><li>其实容器之间关联之后，可以通过容器名进行连接</li><li>MySQL 服务对应的容器名是 mysql，PHP 容器与它关联的名字也是 MySQL，所以把 127.0.0.1 改成 mysql（对应的容器名） 再进行连接即可！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境时基于 docker-compose 管理的 PHP 和 MySQL 服务&lt;br&gt;使用 PHP 连接 docker 容器中的 MySQL 和 Redis 时，报错：Connection refused，也就是在代码中使用 MySql Redis 会报错&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://blog.gotwo.top/categories/PHP/"/>
    
    
      <category term="docker" scheme="https://blog.gotwo.top/tags/docker/"/>
    
      <category term="Connection refused" scheme="https://blog.gotwo.top/tags/Connection-refused/"/>
    
  </entry>
  
  <entry>
    <title>使用git stash命令保存和恢复进度</title>
    <link href="https://blog.gotwo.top/git-stash.html"/>
    <id>https://blog.gotwo.top/git-stash.html</id>
    <published>2019-09-05T11:09:45.000Z</published>
    <updated>2020-11-22T15:25:32.941Z</updated>
    
    <content type="html"><![CDATA[<p>我们有时会遇到这样的情况，正在dev分支开发新功能，做到一半时有人过来反馈一个bug，让马上解决，要切换分支（<code>git checkout</code>），<br>但是新功能做到了一半你又不想提交，这时就可以使用 <code>git stash</code> 命令先把当前进度保存起来，然后切换到另一个分支去修改bug，修改完提交后，再切回dev分支，<br>使用 <code>git stash pop</code> 来恢复之前的进度继续开发新功能。下面来看一下 <code>git stash</code> 命令的常见用法</p><a id="more"></a><h4 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h4><p>保存当前工作进度，会把暂存区和工作区的改动保存起来。执行完这个命令后，在运行 <code>git status</code> 命令，就会发现当前是一个干净的工作区，没有任何改动。使用 <code>git stash save &#39;message...&#39;</code> 可以添加一些注释</p><h4 id="git-stash-list"><a href="#git-stash-list" class="headerlink" title="git stash list"></a>git stash list</h4><p>显示保存进度的列表。也就意味着，<code>git stash</code> 命令可以多次执行。</p><ul><li><code>git stash pop [–index] [stash_id]</code></li><li><code>git stash pop</code> 恢复最新的进度到工作区。git默认会把工作区和暂存区的改动都恢复到工作区。</li><li><code>git stash pop --index</code> 恢复最新的进度到工作区和暂存区。（尝试将原来暂存区的改动还恢复到暂存区）</li><li><code>git stash pop stash@{1}</code> 恢复指定的进度到工作区。stash_id是通过git stash list命令得到的<br>通过<code>git stash pop</code>命令恢复进度后，会删除当前进度。</li></ul><h4 id="git-stash-apply-–index-stash-id"><a href="#git-stash-apply-–index-stash-id" class="headerlink" title="git stash apply [–index] [stash_id]"></a>git stash apply [–index] [stash_id]</h4><p>除了不删除恢复的进度之外，其余和 <code>git stash pop</code> 命令一样。</p><h4 id="git-stash-drop-stash-id"><a href="#git-stash-drop-stash-id" class="headerlink" title="git stash drop [stash_id]"></a>git stash drop [stash_id]</h4><p>删除一个存储的进度。如果不指定stash_id，则默认删除最新的存储进度。</p><h4 id="git-stash-clear"><a href="#git-stash-clear" class="headerlink" title="git stash clear"></a>git stash clear</h4><p>删除所有存储的进度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们有时会遇到这样的情况，正在dev分支开发新功能，做到一半时有人过来反馈一个bug，让马上解决，要切换分支（&lt;code&gt;git checkout&lt;/code&gt;），&lt;br&gt;但是新功能做到了一半你又不想提交，这时就可以使用 &lt;code&gt;git stash&lt;/code&gt; 命令先把当前进度保存起来，然后切换到另一个分支去修改bug，修改完提交后，再切回dev分支，&lt;br&gt;使用 &lt;code&gt;git stash pop&lt;/code&gt; 来恢复之前的进度继续开发新功能。下面来看一下 &lt;code&gt;git stash&lt;/code&gt; 命令的常见用法&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://blog.gotwo.top/categories/Git/"/>
    
    
      <category term="git" scheme="https://blog.gotwo.top/tags/git/"/>
    
      <category term="stash" scheme="https://blog.gotwo.top/tags/stash/"/>
    
  </entry>
  
  <entry>
    <title>Centos 7 开放查看端口 防火墙关闭打开</title>
    <link href="https://blog.gotwo.top/centos7-firewalld-service.html"/>
    <id>https://blog.gotwo.top/centos7-firewalld-service.html</id>
    <published>2019-08-20T15:20:44.000Z</published>
    <updated>2020-11-22T15:25:32.941Z</updated>
    
    <content type="html"><![CDATA[<p>Centos 7 firewall 命令：</p><p>开启防火墙：</p><p><code>systemctl start firewalld.service</code></p><h4 id="查看防火墙状态："><a href="#查看防火墙状态：" class="headerlink" title="查看防火墙状态："></a>查看防火墙状态：</h4><ul><li>查看默认防火墙状态（关闭后显示notrunning，开启后显示running）<br><code>firewall-cmd --state</code> </li></ul><p>*查看已经开放的端口：</p><p><code>firewall-cmd --list-ports</code></p><ul><li>开启端口<br><code>firewall-cmd --zone=public --add-port=80/tcp --permanent</code></li></ul><p>命令含义：</p><p>–zone #作用域</p><p>–add-port=80/tcp #添加端口，格式为：端口/通讯协议</p><p>–permanent #永久生效，没有此参数重启后失效</p><h4 id="重启防火墙"><a href="#重启防火墙" class="headerlink" title="重启防火墙"></a>重启防火墙</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload #重启firewall</span><br><span class="line">systemctl stop firewalld.service #停止firewall</span><br><span class="line">systemctl disable firewalld.service #禁止firewall开机启动</span><br></pre></td></tr></table></figure><p>CentOS 7 以下版本 iptables 命令<br>如要开放80，22，8080 端口，输入以下命令即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">/sbin/iptables -I INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line">/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT</span><br></pre></td></tr></table></figure></p><p>然后保存：</p><p>/etc/rc.d/init.d/iptables save</p><ul><li>查看打开的端口：</li></ul><p><code>/etc/init.d/iptables status</code></p><ul><li>关闭防火墙<br>1） 永久性生效，重启后不会复原</li></ul><p>开启： <code>chkconfig iptables on</code></p><p>关闭： <code>chkconfig iptables off</code></p><p>2） 即时生效，重启后复原</p><p>开启： <code>service iptables start</code></p><p>关闭： <code>service iptables stop</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Centos 7 firewall 命令：&lt;/p&gt;
&lt;p&gt;开启防火墙：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;systemctl start firewalld.service&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;查看防火墙状态：&quot;&gt;&lt;a href=&quot;#查看防火墙状态：&quot; class
      
    
    </summary>
    
      <category term="Linux" scheme="https://blog.gotwo.top/categories/Linux/"/>
    
    
      <category term="centos" scheme="https://blog.gotwo.top/tags/centos/"/>
    
      <category term="防火墙" scheme="https://blog.gotwo.top/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title>virtualbox 虚拟机静态IP设置（debian）</title>
    <link href="https://blog.gotwo.top/vbox-static-ip.html"/>
    <id>https://blog.gotwo.top/vbox-static-ip.html</id>
    <published>2019-08-17T11:29:29.000Z</published>
    <updated>2020-11-22T15:25:32.945Z</updated>
    
    <content type="html"><![CDATA[<p>virtualbox 虚拟机静态IP设置（用于Host Only和NAT共存的方式）</p><p>网卡1：NAT网络<br>网卡2：Host-Only网络</p><p>sudo vim /etc/network/interfaces</p><p>在下面添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 增加的Host-only静态IP设置 (enp0s8 是根据拓扑关系映射的网卡名称（旧规则是eth0,eth1）)</span><br><span class="line"># 可以通过 ```ls /sys/class/net```查看，是否为enp0s8</span><br><span class="line">auto enp0s8</span><br><span class="line">iface enp0s8 inet static</span><br><span class="line">address 192.168.56.101</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.56.0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;virtualbox 虚拟机静态IP设置（用于Host Only和NAT共存的方式）&lt;/p&gt;
&lt;p&gt;网卡1：NAT网络&lt;br&gt;网卡2：Host-Only网络&lt;/p&gt;
&lt;p&gt;sudo vim /etc/network/interfaces&lt;/p&gt;
&lt;p&gt;在下面添加&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="virtualbox" scheme="https://blog.gotwo.top/tags/virtualbox/"/>
    
      <category term="debian" scheme="https://blog.gotwo.top/tags/debian/"/>
    
  </entry>
  
  <entry>
    <title>{@inheritDoc的使用}</title>
    <link href="https://blog.gotwo.top/inheritDoc.html"/>
    <id>https://blog.gotwo.top/inheritDoc.html</id>
    <published>2019-05-13T14:23:31.000Z</published>
    <updated>2020-11-22T15:25:32.941Z</updated>
    
    <content type="html"><![CDATA[<p>{@inheritDoc}的使用<br>这个注释的作用是在：继承的时候 直接把父类的注释都copy下来</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;{@inheritDoc}的使用&lt;br&gt;这个注释的作用是在：继承的时候 直接把父类的注释都copy下来&lt;/p&gt;

      
    
    </summary>
    
      <category term="PHP" scheme="https://blog.gotwo.top/categories/PHP/"/>
    
    
      <category term="inheritDoc" scheme="https://blog.gotwo.top/tags/inheritDoc/"/>
    
  </entry>
  
  <entry>
    <title>PHPMailer发送的时候出现的 SMTP connect() failed 错误</title>
    <link href="https://blog.gotwo.top/phpmailer-failed.html"/>
    <id>https://blog.gotwo.top/phpmailer-failed.html</id>
    <published>2019-04-02T16:51:00.000Z</published>
    <updated>2020-11-22T15:25:32.945Z</updated>
    
    <content type="html"><![CDATA[<p>PHPMailer发送的时候出现的 SMTP connect() failed 错误<br>以前封装好的方法 测试过没问题的 突然今天有问题了<br>查了一下 说是 因为从php5.6以后加入了一些安全校验，这样一来在连接有SSL验证的服务器的话，可能就会产生这样的问题。</p><p>解决方法就是加入这样一段内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$mail-&gt;SMTPOptions = array(</span><br><span class="line">    &apos;ssl&apos; =&gt; array(</span><br><span class="line">        &apos;verify_peer&apos; =&gt; false,</span><br><span class="line">        &apos;verify_peer_name&apos; =&gt; false,</span><br><span class="line">        &apos;allow_self_signed&apos; =&gt; true</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PHPMailer发送的时候出现的 SMTP connect() failed 错误&lt;br&gt;以前封装好的方法 测试过没问题的 突然今天有问题了&lt;br&gt;查了一下 说是 因为从php5.6以后加入了一些安全校验，这样一来在连接有SSL验证的服务器的话，可能就会产生这样的问题。&lt;
      
    
    </summary>
    
      <category term="PHP" scheme="https://blog.gotwo.top/categories/PHP/"/>
    
    
      <category term="PHPMailer" scheme="https://blog.gotwo.top/tags/PHPMailer/"/>
    
      <category term="SMTP" scheme="https://blog.gotwo.top/tags/SMTP/"/>
    
  </entry>
  
  <entry>
    <title>在CentOS 7上安装Sublime Text 3</title>
    <link href="https://blog.gotwo.top/centos7-install-SublimeText3.html"/>
    <id>https://blog.gotwo.top/centos7-install-SublimeText3.html</id>
    <published>2019-02-28T16:18:11.000Z</published>
    <updated>2020-11-22T15:25:32.941Z</updated>
    
    <content type="html"><![CDATA[<p>Sublime Text是一个专有的跨平台多功能文本和源代码编辑器，用于Web和软件开发。它非常快，并且具有许多开箱即用的强大功能。可以通过安装新插件和创建自定义设置来增强其功能。<br><a id="more"></a></p><ul><li><p><strong>首先导入官方Sublime Text存储库的GPG密钥</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -v --import https://download.sublimetext.com/sublimehq-rpm-pub.gpg</span><br></pre></td></tr></table></figure></li><li><p><strong>使用以下命令将Yum存储库添加到系统中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://download.sublimetext.com/rpm/stable/x86_64/sublime-text.repo</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">adding repo from: https://download.sublimetext.com/rpm/stable/x86_64/sublime-text.repo</span><br><span class="line">grabbing file https://download.sublimetext.com/rpm/stable/x86_64/sublime-text.repo to /etc/yum.repos.d/sublime-text.repo</span><br><span class="line">repo saved to /etc/yum.repos.d/sublime-text.repo</span><br></pre></td></tr></table></figure></li><li><p><strong>启用存储库后，键入以下命令安装Sublime Text 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install sublime-text</span><br></pre></td></tr></table></figure></li></ul><p>Sublime Text已安装完成<br>可以在左上角的 应用程序-&gt;编程(Applications -&gt; Programming) 中找到 Sublime Text</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sublime Text是一个专有的跨平台多功能文本和源代码编辑器，用于Web和软件开发。它非常快，并且具有许多开箱即用的强大功能。可以通过安装新插件和创建自定义设置来增强其功能。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.gotwo.top/categories/Linux/"/>
    
    
      <category term="centos" scheme="https://blog.gotwo.top/tags/centos/"/>
    
      <category term="SublimeText3" scheme="https://blog.gotwo.top/tags/SublimeText3/"/>
    
  </entry>
  
  <entry>
    <title>在CentOS 7上安装Google Chrome Web浏览器</title>
    <link href="https://blog.gotwo.top/centos7-install-GoogleChrome.html"/>
    <id>https://blog.gotwo.top/centos7-install-GoogleChrome.html</id>
    <published>2019-02-28T16:17:36.000Z</published>
    <updated>2020-11-22T15:25:32.941Z</updated>
    
    <content type="html"><![CDATA[<p>谷歌浏览器是世界上使用最广泛的网络浏览器。它是为现代网络构建的快速，易用且安全的浏览器。<br>Chrome不是一个开源浏览器，它不包含在CentOS存储库中。它基于Chromium，这是一个开源浏览器，可在EPEL存储库中找到。<br><a id="more"></a></p><h3 id="安装Google-Chrome"><a href="#安装Google-Chrome" class="headerlink" title="安装Google Chrome"></a>安装Google Chrome</h3><p><strong>前提：请确保以具有sudo权限的用户身份登录。</strong></p><p>在CentOS上安装Google Chrome</p><ul><li><p>首先打开终端，使用以下wget命令下载最新的Google Chrome 包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_x86_64.rpm</span><br></pre></td></tr></table></figure></li><li><p>下载文件后，键入以下命令在CentOS 7系统上安装Google Chrome：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum localinstall google-chrome-stable_current_x86_64.rpm</span><br></pre></td></tr></table></figure></li></ul><p>上面的命令将提示您输入用户密码，然后它将安装Chrome和所有其他必需的软件包。</p><h3 id="启动Google-Chrome"><a href="#启动Google-Chrome" class="headerlink" title="启动Google Chrome"></a>启动Google Chrome</h3><p>现在您已经在CentOS系统上安装了Google Chrome(应用程序-&gt;互联网-&gt;Google Chrome)<br><img src="https://raw.githubusercontent.com/xqmGitHub/xqmgithub.github.io/img/hexo/20190228162647.png" alt></p><p>当您第一次启动Google Chrome时，会出现如下窗口，询问您是否要将Google Chrome设置为默认浏览器，并向Google发送使用统计信息和崩溃报告<br>根据您的偏好选择，然后单击OK继续。</p><h3 id="更新Google-Chrome"><a href="#更新Google-Chrome" class="headerlink" title="更新Google Chrome"></a>更新Google Chrome</h3><p>在安装过程中，官方Google存储库将添加到您的系统中。您可以使用cat命令验证文件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/yum.repos.d/google-chrome.repo</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">[google-chrome]</span><br><span class="line">name=google-chrome</span><br><span class="line">baseurl=http://dl.google.com/linux/chrome/rpm/stable/x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://dl.google.com/linux/linux_signing_key.pub</span><br></pre></td></tr></table></figure></p><p>这可确保在通过桌面标准软件更新工具发布新版本时，您的Google Chrome安装将自动更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;谷歌浏览器是世界上使用最广泛的网络浏览器。它是为现代网络构建的快速，易用且安全的浏览器。&lt;br&gt;Chrome不是一个开源浏览器，它不包含在CentOS存储库中。它基于Chromium，这是一个开源浏览器，可在EPEL存储库中找到。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.gotwo.top/categories/Linux/"/>
    
    
      <category term="centos" scheme="https://blog.gotwo.top/tags/centos/"/>
    
      <category term="GoogleChrome" scheme="https://blog.gotwo.top/tags/GoogleChrome/"/>
    
  </entry>
  
  <entry>
    <title>linux下安装composer</title>
    <link href="https://blog.gotwo.top/linux-install-composer.html"/>
    <id>https://blog.gotwo.top/linux-install-composer.html</id>
    <published>2019-02-26T14:26:33.000Z</published>
    <updated>2020-11-22T15:25:32.941Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//安装composer</span><br><span class="line">php -r &quot;copy(&apos;https://install.phpcomposer.com/installer&apos;, &apos;composer-setup.php&apos;);&quot;</span><br><span class="line">php composer-setup.php</span><br><span class="line">sudo mv composer.phar /usr/local/bin/composer</span><br><span class="line">//切换中国镜像</span><br><span class="line">composer config -g repo.packagist composer https://packagist.phpcomposer.com</span><br><span class="line">//更新composer</span><br><span class="line">composer selfupdate</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="PHP" scheme="https://blog.gotwo.top/categories/PHP/"/>
    
    
      <category term="composer" scheme="https://blog.gotwo.top/tags/composer/"/>
    
  </entry>
  
  <entry>
    <title>使用 Travis CI 自动部署 Hexo 到 GitHub 和 Coding</title>
    <link href="https://blog.gotwo.top/travisci-auto-deploy-hexo.html"/>
    <id>https://blog.gotwo.top/travisci-auto-deploy-hexo.html</id>
    <published>2019-02-22T16:08:52.000Z</published>
    <updated>2020-11-22T15:25:32.945Z</updated>
    
    <content type="html"><![CDATA[<p>每次写完一篇文章,都要手动执行hexo g &amp;&amp; gulp和hexo d去生成静态网页后在进行部署到GitHub page和Coding page上去</p><p>而且为了保存文章的源码md文件还需要push到对应的仓库分支上,比较麻烦 就想到了自动部署 网上找了一下最后用<a href="https://travis-ci.com/" target="_blank" rel="noopener">Travis CI</a></p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>本地写完文章 =&gt; push GitHub =&gt; GitHub触发Travis CI构建 =&gt; 执行命令 =&gt; 部署 =&gt; 完成</li></ul><h3 id="Travis-CI设置"><a href="#Travis-CI设置" class="headerlink" title="Travis CI设置"></a>Travis CI设置</h3><ul><li>用GitHub账号登录<a href="https://travis-ci.com/" target="_blank" rel="noopener">Travis CI</a></li><li>然后添加到你要激活的存储库。</li></ul><p><img src="https://i.loli.net/2019/02/22/5c6fb47d6ba45.png" alt></p><ul><li>然后选择你要使用的仓库(放hexo博客的仓库)</li><li>接下来生成GitHub和Coding的Token（生成后页面不要关闭 最好在新标签打开 方便后面复制）</li></ul><p>GitHub传送门<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">GitHub</a></p><p>点击 Generate new token 来生成<br><img src="https://i.loli.net/2019/02/22/5c6fb72e9301e.png" alt></p><p>Coding传送门<a href="https://coding.net/user/account/setting/tokens" target="_blank" rel="noopener">Coding</a></p><p><img src="https://i.loli.net/2019/02/22/5c6fb8a13cc9d.png" alt></p><p>点击右边的 Settings 来添加环境变量（复制刚才生成好的Token）</p><ul><li><strong>CI_TOKEN是GitHub的Token</strong></li><li><strong>CO_TOKEN是Coding的Token</strong></li></ul><p><img src="https://i.loli.net/2019/02/22/5c6fbb6e4702c.png" alt></p><h3 id="在项目根目录新建-travis-yml-文件"><a href="#在项目根目录新建-travis-yml-文件" class="headerlink" title="在项目根目录新建 .travis.yml 文件"></a>在项目根目录新建 <code>.travis.yml</code> 文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line"># 不要用 stable 坑 版本太高 gulp的时候会报错 </span><br><span class="line">- 8.11.3</span><br><span class="line">cache:</span><br><span class="line">  directories:</span><br><span class="line">  - node_modules</span><br><span class="line">before_install:</span><br><span class="line">- npm install hexo-cli -g</span><br><span class="line">install:</span><br><span class="line">- npm install</span><br><span class="line">script:</span><br><span class="line">- hexo clean</span><br><span class="line">- hexo generate &amp;&amp; gulp</span><br><span class="line"></span><br><span class="line">after_script:</span><br><span class="line">  - cd ./public</span><br><span class="line">  - git init</span><br><span class="line">  # GitHub用户名</span><br><span class="line">  - git config user.name &quot;GitHub用户名&quot;</span><br><span class="line">  # GitHub邮箱</span><br><span class="line">  - git config user.email &quot;GitHub邮箱&quot;</span><br><span class="line">  - git add .</span><br><span class="line">  - git commit -m &quot;auto commit by TravisCI at `date +%Y%m%d`&quot;</span><br><span class="line">  # GitHub Pages</span><br><span class="line">  - git push --force --quiet &quot;https://$&#123;CI_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:master </span><br><span class="line">  # Coding Pages 这里的 xxx 是你的Coding名</span><br><span class="line">  - git push --force --quiet &quot;https://xxx:$&#123;CO_TOKEN&#125;@$&#123;CO_REF&#125;&quot; master:master</span><br><span class="line"></span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">  # 这里替换你要监听的分支</span><br><span class="line">  - hexo</span><br><span class="line"></span><br><span class="line">env:</span><br><span class="line"> global:</span><br><span class="line">   # GitHub Pages(GitHub仓库地址)</span><br><span class="line">   - GH_REF: github.com/xxx/xxx.github.io.git</span><br><span class="line">   # Coding Pages(Coding仓库地址)</span><br><span class="line">   - CO_REF: git.coding.net/xxx/xxx.git</span><br><span class="line"></span><br><span class="line"># 这个可以不用</span><br><span class="line"># configure notifications (email, IRC, campfire etc) </span><br><span class="line"># please update this section to your needs!</span><br><span class="line"># https://docs.travis-ci.com/user/notifications/</span><br><span class="line">notifications:</span><br><span class="line">  #你的邮箱</span><br><span class="line">  email:</span><br><span class="line">    - gmail@gmail.com</span><br><span class="line">  on_success: change</span><br><span class="line">  on_failure: always</span><br></pre></td></tr></table></figure><p>之后就直接提交到GitHub就行了 后面的事就交给 Travis CI 去干了</p><p>注 我的仓库分两个分支：hexo和master。hexo作为默认分支，存放博客源代码，master分支存放博客生成页面</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每次写完一篇文章,都要手动执行hexo g &amp;amp;&amp;amp; gulp和hexo d去生成静态网页后在进行部署到GitHub page和Coding page上去&lt;/p&gt;
&lt;p&gt;而且为了保存文章的源码md文件还需要push到对应的仓库分支上,比较麻烦 就想到了自动部署 网上找了一下最后用&lt;a href=&quot;https://travis-ci.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Travis CI&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://blog.gotwo.top/categories/Hexo/"/>
    
    
      <category term="TravisCI" scheme="https://blog.gotwo.top/tags/TravisCI/"/>
    
      <category term="hexo" scheme="https://blog.gotwo.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>test travis-ci</title>
    <link href="https://blog.gotwo.top/test-travis-ci.html"/>
    <id>https://blog.gotwo.top/test-travis-ci.html</id>
    <published>2019-02-22T11:33:18.000Z</published>
    <updated>2020-11-22T15:25:32.945Z</updated>
    
    <content type="html"><![CDATA[<p>测试 TravisCI 自动部署</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;测试 TravisCI 自动部署&lt;/p&gt;

      
    
    </summary>
    
      <category term="Hexo" scheme="https://blog.gotwo.top/categories/Hexo/"/>
    
    
      <category term="travis-ci" scheme="https://blog.gotwo.top/tags/travis-ci/"/>
    
  </entry>
  
  <entry>
    <title>JS Base64编码解码</title>
    <link href="https://blog.gotwo.top/js-bases64.html"/>
    <id>https://blog.gotwo.top/js-bases64.html</id>
    <published>2019-01-18T19:07:49.000Z</published>
    <updated>2020-11-22T15:25:32.941Z</updated>
    
    <content type="html"><![CDATA[<p>Base64编码解码是经常用到的 js怎么用呢 第一反应是找 bases64.js<br>使用很简单，浏览器引入该JS文件，然后Base64编码这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base64.encode(&apos;123456&apos;);</span><br><span class="line">// 返回：&apos;MTIzNDU2&apos;</span><br></pre></td></tr></table></figure><p>解码就调用<code>decode</code>方法，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base64.decode(&apos;MTIzNDU2&apos;);</span><br><span class="line">// 返回：&apos;123456&apos;</span><br></pre></td></tr></table></figure></p><p>就是这么简单。<br>结果，今天发现，尼玛原来浏览器很早就支持了JS Base64加密解密，还花时间去找类库，还要加载一次，只能说JS基础掌握不牢。</p><a id="more"></a><p><strong>原生atob和btoa方法</strong><br>实际上，从IE10+浏览器开始，所有浏览器就原生提供了Base64编码解码方法，不仅可以用于浏览器环境，Service Worker环境也可以使用。</p><ul><li>Base64解码</li></ul><p>语法为（浏览器中）：</p><p><code>var decodedData = window.atob(encodedData);</code><br>或者（浏览器或js Worker线程中）：</p><p><code>var decodedData = self.atob(encodedData);</code><br>例如：</p><p><code>window.atob(&#39;MTIzNDU2&#39;); // 返回：&#39;123456&#39;</code></p><ul><li>Base64编码</li></ul><p>语法为（浏览器中）：</p><p><code>var encodedData = window.btoa(stringToEncode);</code><br>或者（浏览器或js Worker线程中）：</p><p><code>var encodedData = self.btoa(stringToEncode);</code><br>例如：<br><code>window.btoa(&#39;123456&#39;); // 返回：&#39;MTIzNDU2&#39;</code></p><p>还有个问题 中文Base64数据转换会有报错问题</p><p>解决方法，就是中文先encode转码和decode编码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//编码：</span><br><span class="line">window.btoa(window.encodeURIComponent(&apos;我是中文&apos;)); </span><br><span class="line">//返回 JUU2JTg4JTkxJUU2JTk4JUFGJUU0JUI4JUFEJUU2JTk2JTg3</span><br><span class="line"></span><br><span class="line">//解码：</span><br><span class="line">window.decodeURIComponent(window.atob(&apos;JUU2JTg4JTkxJUU2JTk4JUFGJUU0JUI4JUFEJUU2JTk2JTg3&apos;));</span><br><span class="line">//返回 我是中文</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Base64编码解码是经常用到的 js怎么用呢 第一反应是找 bases64.js&lt;br&gt;使用很简单，浏览器引入该JS文件，然后Base64编码这样&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Base64.encode(&amp;apos;123456&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 返回：&amp;apos;MTIzNDU2&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;解码就调用&lt;code&gt;decode&lt;/code&gt;方法，&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Base64.decode(&amp;apos;MTIzNDU2&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 返回：&amp;apos;123456&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;就是这么简单。&lt;br&gt;结果，今天发现，尼玛原来浏览器很早就支持了JS Base64加密解密，还花时间去找类库，还要加载一次，只能说JS基础掌握不牢。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://blog.gotwo.top/categories/JavaScript/"/>
    
    
      <category term="bases64" scheme="https://blog.gotwo.top/tags/bases64/"/>
    
  </entry>
  
</feed>
